diff --git a/sdk/cpprt/linux/libunwind/src/se-iterate-phdr.c b/sdk/cpprt/linux/libunwind/src/se-iterate-phdr.c
index 76c84d74..1e66413d 100644
--- a/sdk/cpprt/linux/libunwind/src/se-iterate-phdr.c
+++ b/sdk/cpprt/linux/libunwind/src/se-iterate-phdr.c
@@ -37,6 +37,7 @@
 #endif
 #include <link.h>
 
+void *get_enclave_base(void);
 /**
  * This function is commonly provided by glibc for application to walk
  * through list of shared objects.  It is needed inside Enclave so that
@@ -51,7 +52,7 @@ int dl_iterate_phdr(
     ElfW(Ehdr)         *ehdr;
 
     memset(&info, 0, sizeof(info));
-    ehdr = (ElfW(Ehdr) *) &__ImageBase;
+    ehdr = (ElfW(Ehdr) *) get_enclave_base()/* &__ImageBase */;
 
     info.dlpi_addr   = (ElfW(Addr)) ehdr;
     info.dlpi_name  = "";
diff --git a/sdk/trts/init_enclave.cpp b/sdk/trts/init_enclave.cpp
index b8c12256..f62fb8db 100644
--- a/sdk/trts/init_enclave.cpp
+++ b/sdk/trts/init_enclave.cpp
@@ -116,7 +116,7 @@ extern "C" int init_enclave(void *enclave_base, void *ms)
         return -1;
     }
 
-    g_enclave_base = (uint64_t)&__ImageBase;
+    g_enclave_base = (uint64_t)get_enclave_base() /* &__ImageBase */;
     g_enclave_size = g_global_data.elrange_size;
     //we are not allowed to set enclave_image_address to 0 if elrange is set
     //so if enclave_image_address is 0, it means elrange is not set
diff --git a/sdk/trts/linux/global_init.c b/sdk/trts/linux/global_init.c
index a180adf3..b316e5cc 100644
--- a/sdk/trts/linux/global_init.c
+++ b/sdk/trts/linux/global_init.c
@@ -40,6 +40,8 @@
 #include <assert.h>
 #include <stdlib.h>
 
+void *get_enclave_base(void);
+
 typedef void (*cxa_function_t)(void *para);
 
 typedef struct _exit_function_t
@@ -143,7 +145,7 @@ static void do_ctors_aux(void)
     fp_t *p = NULL;
     uintptr_t init_array_addr = 0;
     size_t init_array_size = 0;
-    const void *enclave_start = (const void*)&__ImageBase;
+    const void *enclave_start = (const void*)get_enclave_base() /* &__ImageBase */;
 
     if (0 != elf_get_init_array(enclave_start, &init_array_addr, &init_array_size)|| init_array_addr == 0 || init_array_size == 0)
         return;
@@ -164,7 +166,7 @@ static void do_dtors_aux(void)
     fp_t *p = NULL;
     uintptr_t uninit_array_addr;
     size_t uninit_array_size;
-    const void *enclave_start = (const void*)&__ImageBase;
+    const void *enclave_start = (const void*)get_enclave_base() /* &__ImageBase */;
 
     elf_get_uninit_array(enclave_start, &uninit_array_addr, &uninit_array_size);
 
diff --git a/sdk/trts/trts_ecall.cpp b/sdk/trts/trts_ecall.cpp
index bb12e7d2..e7460878 100644
--- a/sdk/trts/trts_ecall.cpp
+++ b/sdk/trts/trts_ecall.cpp
@@ -278,7 +278,7 @@ static sgx_status_t trts_ecall(uint32_t ordinal, void *ms)
                 }
 
                 //change back the page permission
-                size_t enclave_start = (size_t)&__ImageBase;
+                size_t enclave_start = (size_t)get_enclave_base() /* &__ImageBase */;
                 if((status = change_protection((void *)enclave_start)) != SGX_SUCCESS)
                 {
                     sgx_spin_unlock(&g_ife_lock);
@@ -360,7 +360,7 @@ sgx_status_t do_init_thread(void *tcs, bool enclave_init)
     uintptr_t tls_addr = 0;
     size_t tdata_size = 0;
 
-    if(0 != GET_TLS_INFO(&__ImageBase, &tls_addr, &tdata_size))
+    if(0 != GET_TLS_INFO(get_enclave_base() /* &__ImageBase */, &tls_addr, &tdata_size))
     {
         return SGX_ERROR_UNEXPECTED;
     }
diff --git a/sdk/trts/trts_util.cpp b/sdk/trts/trts_util.cpp
index c0b59ef4..517d9cb7 100644
--- a/sdk/trts/trts_util.cpp
+++ b/sdk/trts/trts_util.cpp
@@ -50,7 +50,7 @@ size_t get_enclave_end(void)
 
 void * get_heap_base(void)
 {
-    return GET_PTR(void, &__ImageBase, g_global_data.heap_offset);
+    return GET_PTR(void, get_enclave_base() /* &__ImageBase */, g_global_data.heap_offset);
 }
 
 size_t get_heap_size(void)
@@ -85,7 +85,7 @@ size_t get_heap_min_size(void)
 
 void * get_rsrv_base(void)
 {
-    return GET_PTR(void, &__ImageBase, g_global_data.rsrv_offset);
+    return GET_PTR(void, get_enclave_base() /* &__ImageBase */, g_global_data.rsrv_offset);
 }
 
 size_t get_rsrv_end(void)
diff --git a/common/inc/sgx_random_buffers.h b/common/inc/sgx_random_buffers.h
index 721de3d7..783f2df9 100644
--- a/common/inc/sgx_random_buffers.h
+++ b/common/inc/sgx_random_buffers.h
@@ -281,7 +281,7 @@ private:
         }
     };
 
-    char __bigger_[size()];
+    char __bigger_[size(1)];
 };
 
 template <class T, unsigned M = 0x1000>
diff --git a/psw/enclave_common/sgx_enclave_common.cpp b/psw/enclave_common/sgx_enclave_common.cpp
index ca881a4f..b218ce8b 100644
--- a/psw/enclave_common/sgx_enclave_common.cpp
+++ b/psw/enclave_common/sgx_enclave_common.cpp
@@ -820,6 +820,25 @@ extern "C" void* COMM_API enclave_create_ex(
     
     if (enclave_error != NULL)
         *enclave_error = ENCLAVE_ERROR_SUCCESS;
+
+    // mmap elrange guard page
+    uint64_t elrange_guard_size = 0x1000 /* one page */;
+    if ((MAP_FAILED == mmap((void *)((uint64_t)enclave_base - elrange_guard_size), elrange_guard_size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)) ||
+        (MAP_FAILED == mmap((void *)((uint64_t)enclave_base + virtual_size), elrange_guard_size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)))
+    {
+        SE_TRACE(SE_TRACE_WARNING, "ElrangeGuard unavailable, errno = %d\n", errno);
+        if (enclave_error != NULL)
+        {
+            *enclave_error = ENCLAVE_UNEXPECTED;
+        }
+        if (s_driver_type == SGX_DRIVER_IN_KERNEL)
+        {
+            close_file(&hdevice_temp);
+        }
+        munmap(enclave_base, virtual_size);
+        return NULL;
+    };
+
     return enclave_base;
 }
 
diff --git a/sdk/simulation/urtssim/enclave_creator_sim.cpp b/sdk/simulation/urtssim/enclave_creator_sim.cpp
index 64b9e0e8..33744a7c 100644
--- a/sdk/simulation/urtssim/enclave_creator_sim.cpp
+++ b/sdk/simulation/urtssim/enclave_creator_sim.cpp
@@ -160,6 +160,7 @@ int EnclaveCreatorSim::add_enclave_page(sgx_enclave_id_t enclave_id, void *src,
 
 void reg_sig_handler();
 void reg_sig_handler_sim();
+extern "C" __attribute__((weak)) void reg_sgxsan_sigaction();
 int EnclaveCreatorSim::init_enclave(sgx_enclave_id_t enclave_id, enclave_css_t *enclave_css, SGXLaunchToken *lc, le_prd_css_file_t *prd_css_file)
 {
     UNUSED(prd_css_file);
@@ -169,6 +170,8 @@ int EnclaveCreatorSim::init_enclave(sgx_enclave_id_t enclave_id, enclave_css_t *
     if(false == m_sig_registered)
     {
         reg_sig_handler();
+        if (reg_sgxsan_sigaction)
+            reg_sgxsan_sigaction();
         reg_sig_handler_sim();
         m_sig_registered = true;
     }
diff --git a/sdk/simulation/uinst/u_instructions.cpp b/sdk/simulation/uinst/u_instructions.cpp
index 1989352b..b26e8d24 100644
--- a/sdk/simulation/uinst/u_instructions.cpp
+++ b/sdk/simulation/uinst/u_instructions.cpp
@@ -127,7 +127,7 @@ void call_old_handler(int signum, void* siginfo, void *priv)
 void sig_handler_sim(int signum, siginfo_t *siginfo, void *priv) __attribute__((optimize(0))) __attribute__((optimize("no-stack-protector")));
 void sig_handler_sim(int signum, siginfo_t *siginfo, void *priv)
 {
-    GP_ON(signum != SIGFPE && signum != SIGSEGV);
+    GP_ON(signum != SIGFPE && signum != SIGSEGV && signum != SIGALRM);
 
     thread_data_t *thread_data = 0;
     arch_prctl(ARCH_GET_GS, (unsigned long)&thread_data);
@@ -259,6 +259,8 @@ void reg_sig_handler_sim()
     if (0 != ret) abort();
     ret = sigaction(SIGFPE, &sig_act, &g_old_sigact[SIGFPE]);
     if (0 != ret) abort();
+    ret = sigaction(SIGALRM, &sig_act, &g_old_sigact[SIGALRM]);
+    if (0 != ret) abort();
 }
 
 uintptr_t _EINIT(secs_t* secs, enclave_css_t *css, token_t *launch)
